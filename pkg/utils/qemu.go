package utils

import (
	"bytes"
)
import "text/template"

//QemuSettings struct for pass into template
type QemuSettings struct {
	ConfigDrive string
	DTBDrive    string
	SystemDrive string
	NetDevs     []IFInfo
	HostFWD     map[string]string
	Firmware    string
	MemoryMB    int
	CPUs        int
}

var qemuTemplate = `#qemu config file generated by eden
{{if .ConfigDrive }}
[drive]
  file = "fat:rw:{{ .ConfigDrive }}"
  format = "raw"
{{end}}
{{if .DTBDrive }}
[drive]
  file = "fat:rw:{{ .DTBDrive }}"
  format = "vvfat"
  label = "QEMU_DTB""
{{end}}
[drive]
  file = "{{ .SystemDrive}}"
  format = "qcow2"
{{ range $i, $dev := .NetDevs }}
[device]
  driver = "virtio-net-pci"
  netdev = "eth{{ $i }}"

[netdev "eth{{ $i }}"]
  type = "user"
  net = "{{ $dev.Subnet }}"
  dhcpstart = "{{ $dev.FirstAddress }}"
{{- if eq $i 0 -}}
{{ range $extPort, $intPort := $.HostFWD }}
  hostfwd = "tcp::{{ $extPort }}-:{{ $intPort }}"
{{- end -}}
{{ end }}
{{ end }}
[rtc]
  base = "utc"
  clock = "rt"
{{if .Firmware }}
[machine]
  firmware = "{{ .Firmware}}"
{{end}}
[memory]
  size = "{{ .MemoryMB }}"

[smp-opts]
  cpus = "{{ .CPUs }}"`

//GenerateQemuConfig provides string representation of Qemu config
//for QemuSettings object
func (settings QemuSettings) GenerateQemuConfig() ([]byte, error) {
	t := template.New("t")
	t, err := t.Parse(qemuTemplate)
	if err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	err = t.Execute(buf, settings)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
