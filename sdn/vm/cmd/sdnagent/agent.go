package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/lf-edge/eden/sdn/vm/api"
	"github.com/lf-edge/eden/sdn/vm/pkg/configitems"
	"github.com/lf-edge/eden/sdn/vm/pkg/maclookup"
	dg "github.com/lf-edge/eve/libs/depgraph"
	"github.com/lf-edge/eve/libs/reconciler"
	log "github.com/sirupsen/logrus"
	"github.com/vishvananda/netlink"
)

const (
	// Port connecting SDN VM with the host
	hostPortLogicalLabel = "Host-Port"
)

// suffix is randomly generated by Eden
var hostPortMACPrefix = net.HardwareAddr{0x08, 0x33, 0x33}

type agent struct {
	sync.Mutex
	ctx       context.Context
	macLookup *maclookup.MacLookup

	// Network model
	netModel    parsedNetModel
	newNetModel chan parsedNetModel

	// Configuration state
	currentState  dg.Graph
	intendedState dg.Graph
	registry      reconciler.ConfiguratorRegistry
	failingItems  map[dg.ItemRef]error
	networkIndex  map[string]int // key: network logical label

	// Asynchronous operations
	resumeReconciliation <-chan string      // nil if no async ops
	cancelAsyncOps       context.CancelFunc // nil if no async ops
	waitForAsyncOps      func()             // NOOP if no async ops
}

func (a *agent) init() error {
	a.ctx = context.Background()
	linkChan := a.linkSubscribe(a.ctx.Done())
	a.macLookup = &maclookup.MacLookup{}
	a.macLookup.RefreshCache()
	registry := &reconciler.DefaultRegistry{}
	if err := configitems.RegisterItems(registry, a.macLookup); err != nil {
		return err
	}
	a.registry = registry
	a.newNetModel = make(chan parsedNetModel, 10)
	a.failingItems = make(map[dg.ItemRef]error)
	// Initially start with an empty network model.
	// Ever-present config items will get created.
	// (e.g. DHCP client for the interface connecting SDN with the host)
	a.netModel = parsedNetModel{}
	a.updateCurrentState()
	a.updateIntendedState()
	a.reconcile()
	go a.run(linkChan)
	return nil
}

func (a *agent) run(linkChan chan netlink.LinkUpdate) {
	for {
		select {
		case netModel := <-a.newNetModel:
			// Network model is already validated, applying...
			a.Lock()
			a.netModel = netModel
			a.updateCurrentState()
			a.updateIntendedState()
			a.reconcile()
			a.Unlock()

		case <-a.resumeReconciliation:
			a.Lock()
			a.reconcile()
			a.Unlock()

		case linkUpdate, ok := <-linkChan:
			if !ok {
				log.Warn("Link subscription was closed")
				linkChan = a.linkSubscribe(a.ctx.Done())
				continue
			}
			// If interface appeared or disappeared, refresh the current
			// state graph and potentially reconcile.
			_, found := a.macLookup.GetInterfaceByIndex(int(linkUpdate.Index))
			added := !found
			deleted := linkUpdate.Header.Type == syscall.RTM_DELLINK
			if added || deleted {
				log.Debugf("Important link change: %+v", linkUpdate)
				a.Lock()
				a.macLookup.RefreshCache()
				changed := a.updateCurrentState()
				mac := linkUpdate.Attrs().HardwareAddr
				if bytes.HasPrefix(mac, hostPortMACPrefix) {
					// Intended state for SDN<->Host connectivity changes
					// when the "host port" (dis)appears.
					a.updateIntendedState()
					changed = true
				}
				if changed {
					a.reconcile()
				}
				a.Unlock()
			}

		case <-a.ctx.Done():
			a.Lock()
			if a.cancelAsyncOps != nil {
				a.cancelAsyncOps()
				a.waitForAsyncOps()
				log.Warn("Some asynchronous operations were canceled!")
			}
			a.Unlock()
			return
		}
	}
}

// Called with agent in locked state.
func (a *agent) reconcile() {
	reconcileStartTime := time.Now()
	r := reconciler.New(a.registry)
	status := r.Reconcile(a.ctx, a.currentState, a.intendedState)
	a.currentState = status.NewCurrentState

	// Update variables needed to resume reconciliation
	// after async operation(s).
	if status.AsyncOpsInProgress {
		log.Debug("Some config operations continue in the background")
	}
	a.cancelAsyncOps = status.CancelAsyncOps
	a.resumeReconciliation = status.ReadyToResume
	a.waitForAsyncOps = status.WaitForAsyncOps

	// Log every executed operation.
	for _, opLog := range status.OperationLog {
		var withErr string
		if opLog.Err != nil {
			withErr = fmt.Sprintf(" with error: %v", opLog.Err)
		}
		var verb string
		if opLog.InProgress {
			verb = "started async execution of"
		} else {
			if opLog.StartTime.Before(reconcileStartTime) {
				verb = "finalized async execution of"
			} else {
				// synchronous operation
				verb = "executed"
			}
		}
		log.Infof("State Reconciler %s %v for %v%s, content: %s",
			verb, opLog.Operation, dg.Reference(opLog.Item),
			withErr, opLog.Item.String())
	}

	// Log transitions from no-error to error and vice-versa.
	var failed, fixed []string
	for _, opLog := range status.OperationLog {
		itemRef := dg.Reference(opLog.Item)
		if opLog.Err != nil {
			a.failingItems[itemRef] = opLog.Err
		} else {
			delete(a.failingItems, itemRef)
		}
		if opLog.PrevErr == nil && opLog.Err != nil {
			failed = append(failed, fmt.Sprintf("%v (err: %v)", itemRef, opLog.Err))
		}
		if opLog.PrevErr != nil && opLog.Err == nil {
			fixed = append(fixed, itemRef.String())
		}
	}
	if len(failed) > 0 {
		log.Errorf("Newly failed config items: %s",
			strings.Join(failed, ", "))
	}
	if len(fixed) > 0 {
		log.Infof("Fixed config items: %s",
			strings.Join(fixed, ", "))
	}
}

func (a *agent) linkSubscribe(doneChan <-chan struct{}) chan netlink.LinkUpdate {
	linkChan := make(chan netlink.LinkUpdate, 64)
	linkErrFunc := func(err error) {
		log.Errorf("LinkSubscribe failed %s\n", err)
	}
	linkOpts := netlink.LinkSubscribeOptions{
		ErrorCallback: linkErrFunc,
	}
	if err := netlink.LinkSubscribeWithOptions(
		linkChan, doneChan, linkOpts); err != nil {
		log.Fatal(err)
	}
	return linkChan
}

func (a *agent) allocNetworkIndexes() {
	networkIndex := make(map[string]int)
	// Keep previous indexes which are still needed.
	for _, network := range a.netModel.Networks {
		index, hasIndex := a.networkIndex[network.LogicalLabel]
		if hasIndex {
			networkIndex[network.LogicalLabel] = index
		}
	}
	// Allocate new indexes where needed.
	for _, network := range a.netModel.Networks {
		index, hasIndex := networkIndex[network.LogicalLabel]
		if hasIndex {
			continue
		}
		index = 0
		for a.isNetworkIndexUsed(index) {
			index++
		}
		networkIndex[network.LogicalLabel] = index
	}
	a.networkIndex = networkIndex
}

func (a *agent) isNetworkIndexUsed(index int) bool {
	for _, val := range a.networkIndex {
		if val == index {
			return true
		}
	}
	return false
}

func (a *agent) getNetModel(w http.ResponseWriter, r *http.Request) {
	a.Lock()
	resp, err := json.Marshal(a.netModel.NetworkModel)
	a.Unlock()
	if err != nil {
		errMsg := fmt.Sprintf("failed to marshal network model to JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write(resp); err != nil {
		log.Errorf("Failed to write network model to HTTP response: %v", err)
	}
}

func (a *agent) applyNetModel(w http.ResponseWriter, r *http.Request) {
	var netModel api.NetworkModel
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to read network model from HTTP request: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	err = json.Unmarshal(body, &netModel)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to unmarshal network model from JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	parsedNetModel, err := a.parseNetModel(netModel)
	if err != nil {
		errMsg := fmt.Sprintf("Network model is invalid: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	log.Debugf("Parsed network model: %+v", parsedNetModel)
	a.newNetModel <- parsedNetModel
	w.WriteHeader(http.StatusOK)
}

func (a *agent) getNetConfig(w http.ResponseWriter, r *http.Request) {
	dotExporter := &dg.DotExporter{CheckDeps: true}
	a.Lock()
	dot, err := dotExporter.ExportTransition(a.currentState, a.intendedState)
	a.Unlock()
	if err != nil {
		errMsg := fmt.Sprintf("Failed to export network config to DOT: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "text/vnd.graphviz")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write([]byte(dot)); err != nil {
		log.Errorf("Failed to write network config to HTTP response: %v", err)
	}
}

func (a *agent) getSDNStatus(w http.ResponseWriter, r *http.Request) {
	status := api.SDNStatus{
		MgmtIPs: a.getMgmtIPs(),
	}
	a.Lock()
	for itemRef, err := range a.failingItems {
		status.ConfigErrors = append(status.ConfigErrors, api.ConfigError{
			ItemRef: itemRef,
			ErrMsg:  err.Error(),
		})
	}
	a.Unlock()
	resp, err := json.Marshal(status)
	if err != nil {
		errMsg := fmt.Sprintf("failed to marshal SDN status to JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write(resp); err != nil {
		log.Errorf("Failed to write SDN status to HTTP response: %v", err)
	}
}

func (a *agent) getMgmtIPs() (ips []string) {
	hostNetIf, found := a.macLookup.GetInterfaceByMAC(hostPortMACPrefix, true)
	if !found {
		log.Warnf("failed to find port connecting SDN with the host")
		return
	}
	ifName := hostNetIf.IfName
	link, err := netlink.LinkByName(ifName)
	if err != nil {
		log.Warnf("Failed to get link for interface %s: %v", ifName, err)
		return
	}
	ips4, err := netlink.AddrList(link, netlink.FAMILY_V4)
	if err != nil {
		log.Warnf("Failed to get IPv4 addresses for interface %s: %v", ifName, err)
	}
	ips6, err := netlink.AddrList(link, netlink.FAMILY_V6)
	if err != nil {
		log.Errorf("Failed to get IPv6 addresses for interface %s: %v", ifName, err)

	}
	for _, ip := range ips4 {
		if ip.IP.IsGlobalUnicast() {
			ips = append(ips, ip.IP.String())
		}
	}
	for _, ip := range ips6 {
		if ip.IP.IsGlobalUnicast() {
			ips = append(ips, ip.IP.String())
		}
	}
	return
}

// Gateway to use to route traffic towards host OS.
func (a *agent) getHostGwIP(ipv6 bool) net.IP {
	hostPort, found := a.macLookup.GetInterfaceByMAC(hostPortMACPrefix, true)
	if !found {
		return nil
	}
	var fflags uint64
	filter := netlink.Route{}
	fflags |= netlink.RT_FILTER_TABLE
	filter.Table = syscall.RT_TABLE_MAIN
	fflags |= netlink.RT_FILTER_OIF
	filter.LinkIndex = hostPort.IfIndex
	family := syscall.AF_INET
	if ipv6 {
		family = syscall.AF_INET6
	}
	nlRoutes, err := netlink.RouteListFiltered(family, &filter, fflags)
	if err != nil {
		log.Warnf("netlink.RouteListFiltered failed: %v", err)
		return nil
	}
	for _, nlRoute := range nlRoutes {
		if nlRoute.Gw == nil {
			continue
		}
		if nlRoute.Dst == nil {
			// Nil destination can be used by the default route.
			return nlRoute.Gw
		}
		ones, _ := nlRoute.Dst.Mask.Size()
		if ones == 0 && nlRoute.Dst.IP.IsUnspecified() {
			// Default route matching all IPs.
			return nlRoute.Gw
		}
	}
	return nil
}
